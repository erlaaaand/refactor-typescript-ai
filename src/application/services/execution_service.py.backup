# =============================================================================
"""Execution Service - Executes refactoring plans"""

from pathlib import Path
from typing import List
from datetime import datetime

from ...domain.entities.refactor_plan import RefactorPlan, FileOperation
from ...infrastructure.generators.code_generator import CodeGenerator
from ...shared.utils.file_utils import FileUtils
from ..dto.analysis_result import ExecutionResult


class ExecutionService:
    """Service for executing refactoring plans"""

    def __init__(self, code_generator: CodeGenerator):
        self.code_generator = code_generator
        self.file_utils = FileUtils()

    def execute_plan(self, plan: RefactorPlan, dry_run: bool = False) -> ExecutionResult:
        """Execute a single refactoring plan"""
        print(f"DEBUG execute_plan called for: {getattr(plan, 'id', 'unknown')}")
        print(f"DEBUG Operations count: {len(getattr(plan, 'operations', []))}")
        
        start_time = datetime.now()
        plan.files_created = []
        
        try:
            if dry_run:
                print("DEBUG Dry run - skipping file operations")
                return ExecutionResult(files_created=[])
            
            # Execute operations
            for operation in getattr(plan, 'operations', []):
                print(f"DEBUG Processing operation: {getattr(operation, 'action', 'unknown')} -> {getattr(operation, 'target_path', 'unknown')}")
                if getattr(operation, 'action', '') == "create":
                    self._create_file(operation, plan)
            
            execution_time = (datetime.now() - start_time).total_seconds()
            print(f"DEBUG Execution successful, created {len(getattr(plan, 'files_created', []))} files")
            return ExecutionResult(
                files_created=getattr(plan, 'files_created', []),
                execution_time=execution_time
            )
            
        except Exception as e:
            print(f"DEBUG Execution failed: {e}")
            import traceback
            traceback.print_exc()
            execution_time = (datetime.now() - start_time).total_seconds()
            return ExecutionResult(
                files_created=[],
                execution_time=execution_time,
                error=str(e)
            )

    def _create_file(self, operation: FileOperation, plan: RefactorPlan):
        """Create a new file from operation"""
        print(f"DEBUG _create_file called for: {operation.target_path}")
        content = self._generate_file_content(operation, plan)
        print(f"DEBUG Content generated, length: {len(content)}")
        result = self.file_utils.safe_write(operation.target_path, content, backup=False)
        print(f"DEBUG safe_write result: {result}")
        if result:
            print(f"DEBUG File creation successful for: {operation.target_path}")
        else:
            print(f"DEBUG File creation FAILED for: {operation.target_path}")
        plan.files_created.append(operation.target_path)

    def _generate_file_content(self, operation: FileOperation, plan: RefactorPlan) -> str:
        """Generate file content for operation"""
        print(f"DEBUG _generate_file_content for: {operation.target_path}")
        
        # Use code generator based on plan action
        if plan.action == "split_by_category":
            # For split operations, generate basic test content
            return self.code_generator.generate_file_header(f"Split from {plan.source_file}") + f'''
import {{ Test }} from '@nestjs/testing';

describe('Test Suite', () => {{
  it('should work', () => {{
    expect(true).toBe(true);
  }});
}});
'''
        else:
            # Default content
            return self.code_generator.generate_file_header(f"Generated from {plan.source_file}") + "// Default content\\n"

    def execute_plans(self, plans: List[RefactorPlan],
                     backup: bool = True) -> ExecutionResult:
        """Execute multiple refactoring plans"""

        start_time = datetime.now()
        successful = 0
        failed = 0
        files_created = 0

        for plan in plans:
            try:
                if not plan.is_executable():
                    continue

                # Backup if needed
                if backup and plan.source_file:
                    self.file_utils.safe_write(
                        Path(plan.source_file),
                        Path(plan.source_file).read_text(),
                        backup=True
                    )

                # Execute plan
                result = self.execute_plan(plan)
                if result.success:
                    successful += 1
                    files_created += len(result.files_created)
                else:
                    failed += 1

            except Exception as e:
                print(f"Failed to execute plan {plan.id}: {e}")
                failed += 1

        execution_time = (datetime.now() - start_time).total_seconds()

        return ExecutionResult(
            successful=successful,
            failed=failed,
            files_created=files_created,
            execution_time=execution_time
        )
